구문오류(syntax Error)

의미상오류(Semantic Error)

오류를 줄이는 프로그래밍 습관
 - 조건식에서 상수를 먼저 사용하는 습관 
	1) if(data = 3) 보다는 if (3 = data)
	2) data + 4 + 7 보다는 4 + 7 + data  이 기계어 번역시 연산을 줄여줌
	3) if(data == 3); 보다는 if(data == 3) {



비트연산자
 - & | ^ ~
 - 비트 AND연산자를 통해 특정비트를 0으로 셋팅하는거
 - 비트 OR 연산자를 통해 특정비트를 1로 셋팅하는거
 - 비트 AND 연산자를 통해 특정 번째 비트가 0 인지 1인지 알아보는거 -> 1byte를 bit로 나타내는거
 - A - => A + (~b) + 1

문자/문자열
 - 문자열 끝은 0
 - GetstringLength()함수 만들기
 	int count++
	while(data[count] != 0) 
		count++;
	return;
 - strcat, strcpy 함수 만들기
 
 
	
지역변수
 - 스스로 초기화되지 않는다
 
전역변수
 - 초기화가 없으면 0 으로 자동 초기화됨
 - 함수가 독립성을 잃어버림(함수가 전역 변수에 종속성이 된다)
 - 지역변수와 이름이 같다면, 함수내에서 지역변수가 우선이된다
 - A.c 전역 변수가 설정되어있다면 B.c 에서 extern 을 붙여서 선언해 준다
 - A.C      				B.C
    int g_data1 = 0;	int g_data1;			-> 에러
	int g_data2 = 0;	extern int g_data2;  	-> 정상
						extern int g_data3;  	-> 에러
						extern int g_data4 = 0;	-> 오류 아님
	int g_data5 = 0;	extern int g_data5 = 0;	-> 에러

 - static 은 해당 소스 파일안에 전역으로 설정하면 해당 소스에서만 쓸수있다
 - static 은 특정 함수안에서 선언, 초기화될수 있고, 프로그램과 생명주기를 같이한다. 한번만 초기화되고 값은 유지

const 문법적인 오류를 막아주기 위해서 
 - const int i = 1; 
 - const int* const nPtr = &i;

12.1 배열
 - 초기화 {0,}와 {3,} 차이
 - short int data[] = {1,2,3,4,5} 
 - 사용자 정의 자료 형

12.2 문자열
 - 마지막에 널문자 0 이 추가됨
 - char data[6] = 문자 상수를 사용해서 초기화, 문자열 상수를 사용해서 초기화
 - 문자열 길이 구하는 함수 작성

12.3 2차원배열
 - char data[2][3] = {{1,2,3,},{4,5,6}};
 
13.1 포인터
 - 0x0412 를 0x00000066번지에 2바이트 크기로 대입하라 (mov word ptr[00000066h], 0412h
	 = short int data; data = 0x0412;
 - 직접지정방식의 한계가 있어서 포인터가 필요(매개변수로 넘길순 있지만, 한번에 한개(리턴문이 한개만 지원))
 - 포인터 변수는 32bit프로그래밍에서는 무조건 4byte(64bit 6byte)
 - short* 							ptr 		= 	0x0000006C;
   포인터가가리키는 곳의 데이터 할당 크기 		포인터변수			포인터가 가리키는 주소
 - int n; 
   int* nPtr;
   nPtr = &n;
   *nPtr = 100;
   
13.2 포인터
 - 	short* ptr;
	ptr = (short* )0x0000006c;
	*ptr = 0x0412;
 - 구현
	. swap()함수
 
13.3 포인터와 const키워드
 - const int* const ptr = &data;

13.4 포인터 변수의 주소 연산
 - 	구현
	. 포인터 변수를 선언하고 ++ 했을때
	. 4byte변수의 1byte를 가리키는 포인터 변수 선언 후 접근
	. int형 변수에 저장된 값을 1byte단위로 출력하기

13.6 void*
 - 정해져있지 않다. 어떤형식의 주소든 다 받을 수 있다
 - 구현에서 값을 넣거나 접근할 때 캐스팅이 필요하다
 - 쓰는 사람(사용자)은 편하다 -> 함수로 포인터변수를 여러 타입을 주면 안쓰는건 Null처리해야하고 불편
 - type과 void* 만 던져주면 함수내부에서 캐스팅을 해서 if문으로 갈라주면 된다
 - 구현
	. void *를 사용하여 대상 메모리의 크기 조절하기(int변수를 넘겨주어서 2byte만 확인) -> int GetData(void * p, int type);구현

13.7 포인터 변수에서 형 변환 문법은 모든 자료형에서사용가능하다
 - 	int * p = &data;
	*p = 0x12345678;
	*(short *)p = 0x0000;
	
14.문자와 문자열
 - getchar();
 - getc(stdin);
 - 구현
	. 문자열 입력받아서 버퍼에 저장하는 함수 getchar()이용해서 리미트
	. 문자열 입력받아서 정수로 변환하기

14.4 scanf
 - 자료형을 명시할 때 정확하게 해야한다.
 - %d, %h, %f, %lf, %c, %s
 - 공백으로 구분 된다 
 - 구현
	. 공백문자로 구분해서 여러개의 정보 입력받기, 8진법 10진법, 16진법으로 출력하기
	. scanf_s 나이 입력받기(조건1 정상범위 입력받기)

15.1 배열과 포인터 표기법
 - 배열 표기법 포인터표기법 data[0] 은 *(data + 0) 과 같긴하다
 - 구현
	. 배열 표기법 대신 포인터 표기법을 사용해서 int data[2] = {0x12345678, 0x99999999}를 접근
	. data[1] 의 값을 0x22로 바꾸어라
	. data[1] 의 첫번째 바이트 값을 0x22로 바꾸어라
	
15.2 배열 변수의 이름은 배열의 시작 주소
 - 	char data[4];
	char* p = &data[0];
	char* p = & *(data + 0);
	char* p = data;
15.3 배열을 사용하는 포인터
 - 구현
	. sum += data[select]  는 sum += *(data + select) 와같이 더하기 연산이 반복되어 낭비
	. char * p = data + select;   == char * p = &data[select];
	. 포인터를 이용해 각 배열의 요소를 더하는 거
15.4 포인터 배열 선언
 - char *p[5]; //  char *p0, *p1, *p2, *p3, *p4 와같다
 - char (*p)[5];  --> char *p; 는 1byte를 가리키는 4byte짜리 포인터 변수
 - char (*p)[5]; 는 1byte짜리 5개를 가리키는 4byte짜리 포인터 변수
 - p++; ??
 - 구현
	. char data[3][5]; 
	char (*p)[5];
	p = data; 
	(*p)[1] = 3;
	(*(p+1))[2] = 3;
	(*(p+2))[4] = 5;

16.1 지역 변수와 스택
 - 코드세그먼스(기계어), 데이터 세그먼스(static전역, 전역, 문자열상수), 스택세그먼트(지역변수, 동적메모리)
 - 정적메모리할당 : 컴파일시점에 할당할 메모리의 크기가 결정, 실행시점에 메모리 시작위치 지정
 - 전역변수는 프로그램이 시작해서 종료할 때까지 유지, 실행중에 추가/삭제 불가, 데이터세그먼트에 저장
 - 지역변수는 함수가 호출될 때 메모리에 할당 되었다가 함수가 끝나면 사라짐, 스텍 세그먼트에 저장
 - 정적으로 할당된 메모리를 관리하는 법: 
	. 지역 변수를 사용하려면 변수의 현재 주소를 알아야함
	. 개수를 알아야함
	. 그룹으로 관리해야함
 - 지역변수를 시작위치 포인터와 끝위치 포인터를 통해 관리 가능

16.2 지역 변수와 스택
 - 스택프래임
 - 	push bp
	mov bp, sp
	sub sp, 8
	mov dword ptr[bp], 5
	call tipsoft
	push bp
	push bp, sp
	sub sp, 12
	mov dword ptr[bp-8], 1
	...
	mov sp, bp
	pop bp
	ret
	mov sp, bp
	pop bp
	ret	
16.3 정적 메모리 할당의 한계
 - 스텍이 1MB한계
 - 동적 메모리 할당을통해 
	. 원하는 시점에 원하는 크기만큼 힙여역에 메모리 할당 가능
	. 메모리 사용이 끝나면 언제는 해제 가능
	. 2G까지 할당 가능
 - 구현
	. 사용자로부터 숫자 입력받아 합구하기(case1 최대갯수 사전입력, case2 최대갯수 없이 0입력시 종료)

17.1 다차원 포인터 개념
 - 최대 7개 사용 가능
 - char *p1;  // p1, *p1
 - char **p2;  // p2, *p2, **p2
 - char ***p3;  // p3, *p3, **p3, ***p3;
 
17.2 2차원 포인터의 구성
 - short **pp;   // **pp 는 *(*pp) 와 같다
 - 2차원 포인터는 1차원 포인터의 주소값을 저장한다
 -	. short *pp;
	. int data = 3;	
	. pp = (short **)&data;  // 3번지로간다

 - 	. short **pp, *p, data = 3;
	. p = &data;
	. pp = &p;
	. *pp = 5; 
	
- 2차원 포인터가 가리키는 첫 대상이 일반 변수인 경우
	. short *pp;
	. int data = 3;	
	. int my_ptr = &data;
	. pp = (short **)&my_ptr; 
	. **pp = 5;				//  5로 바뀐다 
	
 
배열과 구조체
 - 친구정보 관리프로그램(치구의 이름나이키 체중관리프로그램)
 - 구조체 멤버 정렬 기준에 따라 할당되는 메모리 크기가 달라질 수 있다(선언시 작은 것부터 같은것 끼리 모아주는게 좋다)
 - 동적할당 선언시 sizeof로 해주는게 안전하다
 - 
 
연결리스트
 - 배열 : 미리정해진 크기, 동적할당 : 사용자에게 크기를 물어보고 입력받아서, 연결리스트는 사용자에게 물어보지 않고 
 - 구현
	.연결리스트의 노드를 구조체로 선언하기
	.노드 추가하며 이어가기
	.반복문으로 마지막 노드 탐색하기
	.조건을 체크하여 새로운 노드 추가하기
	.연결리스트의 마지막 노드 기억하기
	.연결리스트의 전체 노드 제거하기
	.연결리스트의 전체 노드 제거하기(뒤에서부터)
	
#define MAXCOUNT 100
typedef unsigned char UC;
#ifndef _H_
#define _H_
#endif

enum MY = {A,B,C,D}

#ifdef MYDBG
	testcode
#endif


*p++ ===>  *p 하고 p++
*++p
20.1 함수 포인터
 - 함수 원형을 사용해서 포인터를 선언
	. int (*p)(int, int);
	. p = &Sum;
	. (*p)(2,3);
 - 구현
	. int add(int a, int b)... sub mul dev 함수 선언하고 포인터함수 선언해서 사용해보기
	. 반환값이랑 매개변수의 형태가 같으면 주소를 매칭시켜주는 거에 따라 하나의 원형으로 사용가능
	. typedef랑 같이 쓰면 좀 간단
	
 - 함수의 암시적 호출 : 콜백
 - 자신이 사용할 함수가 명시적으로 호출되지 않고 함수 포인터에 의해서 호출되는 방식 
 - 구현
	. 콜백함수 구현하기, 확장성이 좋은