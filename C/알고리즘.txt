선택정렬
주어진 배열에서  제일 작은 값을 제일 앞으로. 교체연산은 매번 한번씩. 복잡도는 n^2
i = 0; i<10;
	j = i; j<10;

버블정렬
주어진 배열에서 제일 큰 값을 맨 뒤로. 교체연산은 매번 3번씩. 복잡도는 n^2
i=0; i<10;
	j=0; j<10-i;
	
삽입정렬(거의 정렬되어있을땐 가장 빠름)
주어진 배열에서 순차적으로 판단해볼때 앞으로 삽입할 위치를 판단하여 거기까지만 가서 삽입. 복잡도는 n^2
특정한 원소를 기준으로 앞에 있는것은 정렬되어있다고 가정하기때문에 거기까지만 판단하면됨
i=0; i<9;
	j=i;
	while(a[j] > a[j+1])

퀵정렬(분할 정복) 일반적으로 nlog2n 최악 n^2
첫번째 피봇을 선택하고
왼쪽에서는 큰값을 찾아가고 오른쪽에서는 작은값을 찾아간다 -> 찾으면 서로 위치를 바꾸고 피봇은 유지한다
작은값의 인덱스가 큰값의 인덱스보다 크면 = 엇갈리면 작은값과 피봇을 바꾼다 이때 분할이됨
새로 제일 앞의 값을 피봇으로 설정하고 위 과정을 반복한다
이미 정렬되어 있을때  n^2  최악으로 나온다

병합정렬
일단 반으로 쪼개고 나중에 합친다 무조건 반으로 쪼개니까 n의 개수만큼 log2n이므로 
nlog2n
추가적인 메모리공간이 필요하다

힙정렬
힙트리 구조를 이용한 정렬
부모가 자식보다 큰 구조. 
힙피파이 구조만들고 제일 첫번재 노드를 마지막으로 옮기고 ->마지막 제외하고 다시 힙피파이 만들고 첫번째 노드를 마지막-1로 옮기고 반복
n logn


BFS
큐를 사용
1. 노드를 큐에 넣어주고 
2. 해당노드는 방문처리를 한다
3. 큐에서 하나의 노드를 꺼내고
해당 노드에 연결된 노드중 방문하지 않은 노드를 방문하고 차례로 큐에 넣어준다
	1 큐에 넣고 방문처리한다
	1 꺼내고 인접한 1 2 3   중 방문하지 않은 2 3 을 큐에 넣고 2 3 은 방문처리 한다
	2 꺼내고 인접한 1 3 4 5 중 방문하지 않은 4 5 를 큐에 넣고 4 5 는 방문처리 한다
	3 꺼내고 인접한 1 2 6 7 중 방문하지 않은 6 7 을 큐에 넣고 6 7 은 방문처리 한다
	4 꺼내고 인접한 2 5중 방문하지 않은 노드는 없으므로 큐에 넣을 것이 없고 
	5 꺼내고 인접한 2 4중 방문하지 않은 노드는 없으므로 큐에 넣을 것이 없고
	6 꺼내고 인접한 3 7중 방문하지 않은 노드는 없으므로 큐에 넣을 것이 없고
	7 꺼내고 인접한 3 6중 방문하지 않은 노드는 없으므로 큐에 넣을 것이 없고
	끝
	
DFS
스택을 사용
1. 시작노드를 스택에 넣고 방문처리
2. 스택의 최상단 노드를 확인(마지막에 들어온)
3. 스택의 최상단 노드에 인접한 방문하지 않은 노드를 스택에 넣고 방문처리
4. 방문하지 않은 인접 노드가 없으면 최상단 노드를 뺀다

	1 스택에 넣고 방문처리
	1 에 인접한 2 3     중 방문하지 않은 2 3   중 적은 2를 스택에 넣고 방문처리
	2 에 인접한 1 4 5 6 중 방문하지 않은 3 4 5 중 적은 3을 스택에 넣고 방문처리
	3 에 인접한 1 2 6 7 중 방문하지 않은 6 7   중 적은 6을 스택에 넣고 방문처리
	6 에 인접한 3 7     중 방문하지 않은 7            을 스택에 넣고 방문처리
	7 은 인접한 3 6     중 방문하지 않은 노드가 없으므로 꺼내기(처리, 종료)
	6 스택에서 제거
	3 스택에서 제거
	2 에 인접한 1 3 4 5 중 방문하지 않은 4 5   중 적은 4를 스택에 넣고 방문처리
	4 에 인접한 2 5     중 방문하지 않은 5            를 스택에 넣고 방문처리
	5 스택에서 제거
	4 스택에서 제거
	2 스택에서 제거
	1 스택에서 제거
	